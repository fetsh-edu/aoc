module Day01 exposing (solve)

import Math exposing (abs, modBy)

dialSize : Int
dialSize =
    100


startPos : Int
startPos =
    50


solve : String -> { part1 : String, part2 : String }
solve input =
    let
        rotations =
            parseRotations input
    in
    { part1 = solvePart1 rotations |> String.fromInt
    , part2 = solvePart2 rotations |> String.fromInt
    }


solvePart1 : Array Int -> Int
solvePart1 rotations =
    rotations
        |> Array.foldl
            (\rotation acc ->
                let
                    lastPosition =
                        Array.last acc.positions
                            |> Maybe.withDefault startPos

                    newPosition =
                        rotate lastPosition rotation
                in
                { positions = Array.pushLast newPosition acc.positions
                , count =
                    if newPosition == 0 then
                        acc.count + 1
                    else
                        acc.count
                }
            )
            { positions = [ startPos ], count = 0 }
        |> .count


solvePart2 : Array Int -> Int
solvePart2 rotations =
    rotations
        |> Array.foldl
            (\rotation acc ->
                let
                    newPosition =
                        rotate acc.position rotation

                    crossings =
                        countZeroCrossings acc.position rotation
                in
                { position = newPosition
                , totalCrossings = acc.totalCrossings + crossings
                }
            )
            { position = startPos, totalCrossings = 0 }
        |> .totalCrossings


parseRotations : String -> Array Int
parseRotations input =
    input
        |> String.lines
        |> Array.map String.trim
        |> Array.foldl
            (\line acc ->
                when parseRotation line is
                    Just rotation ->
                        Array.pushLast rotation acc

                    Nothing ->
                        acc
            )
            []


parseRotation : String -> Maybe Int
parseRotation input =
    let
        firstChar =
            String.slice 0 1 input

        rest =
            String.dropFirst 1 input
    in
    when firstChar is
        "L" ->
            String.toInt rest
                |> Maybe.map (\n -> -n)

        "R" ->
            String.toInt rest

        _ ->
            Nothing


rotate : Int -> Int -> Int
rotate init rotation = modBy dialSize (init + rotation)


countZeroCrossings : Int -> Int -> Int
countZeroCrossings init rotation =
    let
        distance =
            abs rotation

        first =
            if init == 0 then
                dialSize
            else if rotation >= 0 then
                dialSize - init
            else
                init
    in
    if distance >= first then
        1 + (distance - first) // dialSize

    else
        0
